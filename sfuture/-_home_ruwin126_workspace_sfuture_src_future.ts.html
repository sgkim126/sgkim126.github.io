<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />

	<title>sfuture Source: /home/ruwin126/workspace/sfuture/src/future.ts</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.default.css">

	
	<link type="text/css" rel="stylesheet" href="styles/site.cerulean.css">
	
	<style>
		.sideMenu
		{
			margin-left: 320px!important;

		}
		#main
		{
			margin-top: 46px;
		}
		#mainMenu
		{
			position: fixed;
			left: 0px;
			top: 0px;
			
		}

		#searchBox
		{
			vertical-align: none !important;
			padding-right: 0px;
			width:238px;

		}
		.sideMargin
		{
			margin-left: 15px;
		}
		.sunlight-code-container
		{
			border:none!important;
		}
		.navTitle
		{
			font-size:15px;
			padding:0px;

		}
		.nav-list
		{
			width: 100%;
		}
		.nav-list
		{
			padding-left:20px;
		}		
		.nav-list li
		{
			line-height: 16px;
		}
		.handCursor
		{
			cursor: pointer;
		}
		.nav-pills > li > a {
			padding-top: 0px;
			padding-bottom: 0px;
		}

		#projectTitle
		{
			position: fixed;
			padding-left: 10px;
			padding-top: 5px;
			font-size: 26px;
			font-weight: lighter;
			letter-spacing: -1px;
			background-color: #FFF;
			width: 100%;
			height: 35px;
			line-height: 18px;
			color: #000;
			border-bottom: 1px solid rgba(0,0,0,.2);
			z-index: 10;
		}
		h1, h2, h3, h4, h5, h6 {
			font-family: 'Helvetica Neue';
			font-weight: lighter;
		}
		h3
		{
			font-size: 22px;
			font-weight: lighter;
		}
		.page-title
		{
			font-weight: lighter;
			font-size: 28px;
			letter-spacing: -2px;
			padding-top:0px;
		}

		.well
		{
			padding: 5px;
			width:280px;
			margin-left:0px;
		}


		.menuFrame
		{
			margin-top: 20px;
			overflow:hidden; 
			overflow-y:auto;
		}
		.menuFrame::-webkit-scrollbar {
		    -webkit-appearance: none;
		}

		.menuFrame::-webkit-scrollbar:vertical {
		    width: 11px;
		}

		.menuFrame::-webkit-scrollbar:horizontal {
		    height: 11px;
		}

		.menuFrame::-webkit-scrollbar-thumb {
		    border-radius: 8px;
		    border: 2px solid white; /* should match background, can't be transparent */
		    background-color: rgba(0, 0, 0, .5);
		}
		
		.container-fluid
		{
			padding-left: 10px;
		}

		#side-menu
		{
			height: 415px;
			box-shadow: inset 0 0 10px rgba(0,0,0,.5);
			border: 1px solid #999;
		}

		#menuAside
		{
			margin-top:50px;
			position:fixed;
		}

		.member {
			font-size: 14px;
			color:#000;
			background-color:#FFF;
			border:1px solid #2fa4e7;
		}
		.member:hover {

			background-color:#F6F6F6;
		}		
		.member-open .paramSignature{
			font-size: 14px;
			color: #2fa4e7;
		}
		.member-collapsed .paramSignature{
			font-size: 14px;
			color: #2fa4e7;
		}
		.routeTitle{
		    cursor: pointer;
		}

		.genericAnnotation
		{
		    color:#2fa4e7;
		}

		.sourceBar
		{
			margin-top: -5px;
		}



.twitter-typeahead
{
	top: -5px;
}
.twitter-typeahead .tt-query,
.twitter-typeahead .tt-hint {
  margin-bottom: 0;
  background-color: #F00;
  border-radius: 20px;

}

.tt-hint
{
	top: 2px!important;

    padding-left: 10px!important;  
    width: 188px;
    text-indent: 4px;
}
.tt-dropdown-menu {
  min-width: 160px;
  margin-top: 2px;
  padding: 5px 0;
  background-color: #fff;
  border: 1px solid #ccc;
  border: 1px solid rgba(0,0,0,.2);
  *border-right-width: 2px;
  *border-bottom-width: 2px;
  -webkit-border-radius: 6px;
     -moz-border-radius: 6px;
          border-radius: 6px;
  -webkit-box-shadow: 0 5px 10px rgba(0,0,0,.2);
     -moz-box-shadow: 0 5px 10px rgba(0,0,0,.2);
          box-shadow: 0 5px 10px rgba(0,0,0,.2);
  -webkit-background-clip: padding-box;
     -moz-background-clip: padding;
          background-clip: padding-box;
}

.tt-suggestion {
  display: block;
  padding: 3px 20px;
}

.tt-suggestion.tt-is-under-cursor {
  color: #fff;
  background-color: #0081c2;
  background-image: -moz-linear-gradient(top, #0088cc, #0077b3);
  background-image: -webkit-gradient(linear, 0 0, 0 100%, from(#0088cc), to(#0077b3));
  background-image: -webkit-linear-gradient(top, #0088cc, #0077b3);
  background-image: -o-linear-gradient(top, #0088cc, #0077b3);
  background-image: linear-gradient(to bottom, #0088cc, #0077b3);
  background-repeat: repeat-x;
  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff0088cc', endColorstr='#ff0077b3', GradientType=0)
}

.tt-suggestion.tt-is-under-cursor a {
  color: #fff;
}

.tt-suggestion p {
  margin: 0;
}

	</style>
</head>

<body>
<div id="projectTitle">
	<div id="btnCollapse" class="btn collapseSidebarButton btn-primary"><i class="icon-th-list icon-white"></i></div>
	sfuture
</div>	
<div class="container-fluid">

	<div id="menuAside">
    <aside class="well span3 oc" id="side-menu" role="navigation">

    	<div style="margin-left: 10px; margin-top: 10px;">
			<input type="text" id="searchBox" class="search-query typeahead" placeholder="Search">
		</div>
		<div class="menuFrame" id="sideMenuFrame">
		<ul id="menuContainer" class="nav nav-pills nav-stacked">
			<li class="nav-header navTitle"><a href="index.html">INDEX</a></li>
				<li class="divider"></li>
				
				
					    <li id="navTitle_Classes" class="nav-header navTitle">
                            <a class="handCursor" data-toggle="collapse" data-id="T_Classes" data-target="#collapse_Classes">Classes<span class="badge badge-info pull-right">1</span></a>
                        </li>
                        <li id="navContents_Classes">
                            <div id="collapse_Classes" class="collapse">
                                <ul class="nav nav-list" style="width:100%;margin-left:-8px;">
                                    <li><a href="Future.html">Future</a></li>
                            
                                    </ul>
                                </div>
                            </li>
                        
					    <li id="navTitle_Callbacks" class="nav-header navTitle">
                            <a class="handCursor" data-toggle="collapse" data-id="T_Callbacks" data-target="#collapse_Callbacks">Callbacks</a>
                        </li>
                        <li id="navContents_Callbacks">
                            <div id="collapse_Callbacks" class="collapse">
                                <ul class="nav nav-list" style="width:100%;margin-left:-8px;">
                                    <li><a href="html#ApplyCallback">ApplyCallback</a></li><li><a href="html#FailCallback">FailCallback</a></li><li><a href="html#FilterCallback">FilterCallback</a></li><li><a href="html#FlatMapCallback">FlatMapCallback</a></li><li><a href="html#FoldCallback">FoldCallback</a></li><li><a href="html#MapCallback">MapCallback</a></li><li><a href="html#RecoverCallback">RecoverCallback</a></li><li><a href="html#RecoverWithCallback">RecoverWithCallback</a></li><li><a href="html#SuccessCallback">SuccessCallback</a></li><li><a href="html#TryCallback">TryCallback</a></li>
                            
                                    </ul>
                                </div>
                            </li>
                        

		</ul>
		</div>

		<script>
			var searchMembers = [{"realName":"Future","link":"Future"},{"realName":"ApplyCallback","link":""},{"realName":"FailCallback","link":""},{"realName":"FilterCallback","link":""},{"realName":"FlatMapCallback","link":""},{"realName":"FoldCallback","link":""},{"realName":"MapCallback","link":""},{"realName":"RecoverCallback","link":""},{"realName":"RecoverWithCallback","link":""},{"realName":"SuccessCallback","link":""},{"realName":"TryCallback","link":""}];
		</script>
    </aside>
	</div>
    <div id="docContents" class="sideMenu sideMargin">

		
			<div style="width:100%">
		
				<div id="main">
					


		<h1 class="page-title">Source: /home/ruwin126/workspace/sfuture/src/future.ts</h1>
    
    <section>
        <article>
            <pre class="sunlight-highlight-javascript ">import util = require('util');

class Future&lt;T> {
  /**
   * @private
   * @type Promise&lt;T>
   */
  private promise: Promise&lt;T>;

  /**
   * Creates a new future with ES6 promise.
   * The new future will be completed when the promise is completed.
   * @class Future&lt;T>
   */
  constructor(promise: Promise&lt;T>) {
    this.promise = promise;
  }

  /**
   * Returns a failed future if err is defined.
   * @method Future.failed
   * @param {any} err
   * @returns {Future&lt;T>}
   */
  static failed&lt;T>(err: any): Future&lt;T> {
    let newPromise = Promise.reject(err);

    return new Future&lt;T>(newPromise);
  }

  /**
   * Returns a successful future that holds the given value.
   * @method Future.successful
   * @param {T} value
   * @returns {Future&lt;T>}
   */
  static successful&lt;T>(result: T): Future&lt;T> {
    let newPromise = Promise.resolve&lt;T>(result);

    return new Future&lt;T>(newPromise);
  }

  /**
   * Returns a failed future if err is defined.
   * Returns a successful future if err is not defined.
   * @method Future.fromTry
   * @param {any} err
   * @param {T} value
   * @returns {Future&lt;T>}
   */
  static fromTry&lt;T>(err: any, result: T): Future&lt;T> {
    let newPromise = err ? Promise.reject(err) : Promise.resolve&lt;T>(result);

    return new Future&lt;T>(newPromise);
  }


  /**
   * Creates a future with callback. Callback will be executed asynchronously.
   * So the future is not completed when it is returned.
   * @method Future.apply
   * @param {ApplyCallback} callback
   * @returns {Future&lt;T>}
   */
  static apply&lt;T>(fn: () => T): Future&lt;T> {
    let newPromise = new Promise&lt;T>((resolve, reject): void => {
      setTimeout(
        (): void => {
          try  {
            let result = fn();
            resolve(result);
          } catch (ex) {
            reject(ex);
          }
        },
        0);
    });
    return new Future&lt;T>(newPromise);
  }


  /**
   * Reduces futures to one future.
   * @method Future.sequence
   * @param {Array.&lt;Future&lt;T>>} futures
   */
  static sequence&lt;T>(futures: Future&lt;T>[]): Future&lt;T[]> {
    let newPromise = Promise.all(futures.map((f): Promise&lt;T> => {
      return f.promise;
    }));
    return new Future&lt;T[]>(newPromise);
  }

  /**
   * Returns the first completed futures.
   * @method Future.firstCompletedOf
   * @param {Array.&lt;Future&lt;T>>} futures
   */
  static firstCompletedOf&lt;T>(futures: Future&lt;T>[]): Future&lt;T> {
    let newPromise = Promise.race(futures.map((f): Promise&lt;T> => {
      return f.promise;
    }));
    return new Future&lt;T>(newPromise);
  }

  /**
   * Returns a future that holds the value which callback returns true.
   * If no value contents the callback, the future holds null.
   * @method Future.find
   * @param {Array.&lt;Future&lt;T>>} futures
   * @param {FilterCallback} callback
   * @returns {Future&lt;T>}
   */
  static find&lt;T>(futures: Future&lt;T>[], predicate: (result?: T) => boolean): Future&lt;T> {
    let count = futures.length;

    if (count === 0) {
      return Future.successful(null);
    }

    let newPromise = new Promise&lt;T>((resolve, reject) => {
      let search: (err?: any, result?: T) => void = (err: any, result: T): void => {
        count -= 1;
        if (!err) {
          try {
            if (predicate(result)) {
              resolve(result);
              return;
            }
          } catch (ex) {
            // Ignore error.
          }
        }

        if (count === 0) {
          resolve(null);
          return;
        }
      };

      futures.map((future: Future&lt;T>): void => {
        future.onComplete(search);
      });
    });

    return new Future(newPromise);
  }

  /**
   * Folds with the given futures and the given base value.
   * The fold will be executed after all the given futures are completed
   * successfully. And returns the first failed future if one of the future
   * is failed
   * @method Future.fold
   * @param {Array.&lt;Future&lt;T>>} futures
   * @param {U} base
   * @param {FoldCallback} callback
   * @returns Future&lt;U>
   */
  static fold&lt;T, R>(futures: Future&lt;T>[], base: R, op: (base: R, result: T) => R): Future&lt;R> {
    return Future.sequence(futures)
    .map((results: T[]): R => {
      return results.reduce(op, base);
    });
  }

  /**
   * Reduces with the given futures and the callback.
   * The reduce will be executed after all the given futures are completed
   * successfully. And returns the first failed future if one of the future
   * is failed
   * @method Future.reduce
   * @param {Array.&lt;Future&lt;T>>} futures
   * @param {FoldCallback} callback
   * @returns Future&lt;T>
   */
  static reduce&lt;T>(futures: Future&lt;T>[], op: (base: T, result: T) => T): Future&lt;T> {
    if (futures.length === 0) {
      return Future.failed(new Error('reduce attempted on empty collection'));
    }

    return Future.sequence(futures)
    .map((results: T[]): T => {
      let remains = results.slice(0);
      let first = remains.shift();

      return remains.reduce(op, first);
    });
  }

  /**
   * Converts T[] to Future&lt;U[]> with T[] and function(T => Future&lt;U>).
   * @method Future.traverse
   * @param {Array.&lt;T>} args
   * @param {FlatMapCallback} callback
   * @returns {Array.&lt;Future&lt;U>>}
   */
  static traverse&lt;T, R>(args: T[], fn: (result?: T) => Future&lt;R>): Future&lt;R[]> {
    return Future.sequence(args.map(fn));
  }

  /**
   * Creates a future with function and it's arguments. The last parameter of
   * function should be the node style callback.
   * @method Future.denodify
   * @param {function} fn
   * @param {any} thisArg
   * @param {...any} args
   * @returns {Future&lt;T>}
   */
  static denodify&lt;T>(fn: Function, thisArg: any, ...args: any[]): Future&lt;T> {
    let newPromise = new Promise&lt;T>((resolve, reject): void => {
      args.push((err: any, result: T): void => {
        if (err) {
          reject(err);
          return;
        }

        resolve(result);
      });

      fn.apply(thisArg, args);
    });
    return new Future&lt;T>(newPromise);
  }

  /**
   * Executes callback when this future is completed successfully.
   * @method Future#onSuccess
   * @param {SuccessCallback} callback
   * @returns {Future&lt;T>}
   */
  onSuccess(callback: (result?: T) => void): Future&lt;T> {
    this.promise.then(callback);
    return this;
  }

  /**
   * Executes callback when this future is failed.
   * @method Future#onFailure
   * @param {FailCallback} callback
   * @returns {Future&lt;T>}
   */
  onFailure(callback: (err?: any) => void): Future&lt;T> {
    this.promise.catch(callback);
    return this;
  }

  /**
   * Executes callback when this future is completed.
   * It is similar to {@link Future#andThen}, but it returns this future itself.
   * @method Future#onComplete
   * @param {TryCallback} callback
   * @returns {Future&lt;T>}
   */
  onComplete(callback: (err?: any, result?: T) => void): Future&lt;T> {
    this.promise.then(
      (value: T): void => {
        callback(undefined, value);
      },
      callback
    );
    return this;
  }


  /**
   * Does nothing when this future failed.
   * If this future completed successfully, executes callback.
   * It is simillar to {@link Future#onSuccess}, but returns void.
   * @method Future#foreach
   * @param {SuccessCallback} callback
   */
  foreach&lt;U>(f: (result?: T) => U): void {
    this.onSuccess(f);
  }

  /**
   * If this future is completed successfully, it returns a future that holds
   * the successCallback applied.
   * And if this future is failed, it returns a failed future. The reason
   * will be the result of failCallback.
   * @method Future#transform
   * @param {SuccessCallback} successCallback
   * @param {FailCallback} failCallback
   * @returns {Future&lt;U>}
   */
  transform&lt;U>(s: (result?: T) => U, f: (err?: any) => any): Future&lt;U> {
    let newPromise = this.promise.then(
      s,
      (err: any): U => {
        throw f(err);
      }
    );
    return new Future&lt;U>(newPromise);
  }

  /**
   * Returns a new future that callback is applied when this future is
   * completed successfully.
   * If this future is failed, the new future will be failed with the same
   * reason with this future.
   * @method Future#map
   * @param {MapCallback} callback
   * @returns {Future&lt;U>}
   */
  map&lt;U>(mapping: (result?: T) => U): Future&lt;U> {
    let newPromise = this.promise.then(mapping);
    return new Future&lt;U>(newPromise);
  }

  /**
   * If this future is completed successfully, returns a new future that is
   * the same with callback result. So callback should return future.
   * If this future is failed, the new future will be failed with the same
   * reason with this future.
   * @method Future#flatMap
   * @param {FlatMapCallback} callback
   * @returns {Future&lt;U>}
   */
  flatMap&lt;U>(futuredMapping: (result?: T) => Future&lt;U>): Future&lt;U> {
    let newPromise = this.promise.then(
      (value: T): Promise&lt;U> => {
        return futuredMapping(value)
        .promise;
      }
    );

    return new Future&lt;U>(newPromise);
  }

  /**
   * Returns a new future that holds the filtered value with callback.
   * If callback returns true, the new future holds the same value with this
   * future. If callback retruns false, the new future will be failed.
   * @method Future#filter
   * @param {FilterCallback} callback
   * @returns {Future&lt;T>}
   */
  filter(filterFunction: (result?: T) => boolean): Future&lt;T> {
    let newPromise = this.promise.then(
      (value: T): T => {
        if (!filterFunction(value)) {
          throw new Error('no.such.element');
        }
        return value;
      }
    );

    return new Future&lt;T>(newPromise);
  }

  /**
   * Same with {@link Future#filter}.
   * @method Future#withFilter
   */
  withFilter(filterFunction: (result?: T) => boolean): Future&lt;T> {
    return this.filter(filterFunction);
  }


  /**
   * Returns a new future that holds the value that callback is applied.
   * Or returns a failed future if callback returns undefined. This callback
   * is applied only when this future is completed successfuly.
   * @method Future#collect
   * @param {SuccessCallback} callback
   * @returns {Future&lt;U>}
   */
  collect&lt;S>(pf: (result?: T) => S): Future&lt;S> {
    return this.map((value: T): S => {
      let result: S = pf(value);
      if (result === undefined) {
        throw new Error(util.format('Future.collect partial function is not defined at: %j', value));
      }

      return result;
    });
  }

  /**
   * Takes a callback and executes callback when this future is failed. And
   * returns new future holds the callback result.
   * @method Future#recover
   * @param {RecoverCallback} callback - It is executed when this future failed.
   * @returns {Future&lt;T>}
   */
  recover(recoverFunction: (err?: any) => T): Future&lt;T> {
    let newPromise = this.promise.catch(recoverFunction);

    return new Future&lt;T>(newPromise);
  }

  /**
   * Takes a callback that returns Future. And executes callback when this
   * future is failed. And returns a new future that is the same with callback
   * result.
   * @method Future#recoverWith
   * @param {RecoverWithCallback} callback - It is executed when this future failed.
   * @returns {Future&lt;T>}
   */
  recoverWith(recoverFunction: (err?: any) => Future&lt;T>): Future&lt;T> {
    let newPromise = this.promise.catch(
      (err: any): Promise&lt;T> => {
        return recoverFunction(err).promise;
      }
    );

    return new Future&lt;T>(newPromise);
  }

  /**
   * Returns a new future that holds the result of this and the passed future.
   * The zip method of scala returns a future of tuple, but sfuture's one
   * holds size 2 array.
   * @method Future#zip
   * @param {Future&lt;U>} future
   * @returns {Future&lt;Array.&lt;any>>} - The array size should be 2.
   */
  zip&lt;U>(future: Future&lt;U>): Future&lt;any[]> {
    return Future.sequence&lt;any>([ this, future ]);
  }

  /**
   * Returns a new future. The new future will be failed when both this future
   * and the passed future is failed. The reason will be the same with this
   * future.
   * The new future holds the same value with this future, if this future is
   * completed successfully. And holds the same value with the passed future,
   * if this future is failed and the passed future is successful.
   * @method Future#fallbackTo
   * @param {Future&lt;T>} future - fallback future
   * @returns {Future&lt;T>}
   */
  fallbackTo(future: Future&lt;T>): Future&lt;T> {
    let newPromise = new Promise&lt;T>((resolve, reject): void => {
      this.onSuccess(resolve)
      .onFailure((err: any): void => {
        future.onSuccess(resolve)
        .onFailure((_: any): void => {
          reject(err);
        });
      });
    });

    return new Future&lt;T>(newPromise);
  }

  /**
   * Applies the side-effect function and returns a new future with the result
   * of this future.
   * The result future is completed after this future is completed. So andThen
   * chains keeps the order.
   * @method Future#andThen
   * @param {TryCallback} callback
   * @returns {Future&lt;T>} Holds the same result with this future.
   */
  andThen(callback: (err?: any, result?: T) => void): Future&lt;T> {
    let newPromise = this.promise.then(
      (value: T): T => {
        try {
          callback(undefined, value);
        } catch (ex) {
          return value;
        }
        return value;
      },
      (err: any): void => {
        try {
          callback(err);
        } catch (ex) {
          throw err;
        }
        throw err;
      }
    );

    return new Future&lt;T>(newPromise);
  }


  /**
   * Receives node-style callback. The callback is executed after this future
   * completed.
   * @method Future#nodify
   * @param {TryCallback} callback
   */
  nodify(callback: (err?: any, result?: T) => void): void {
    this.promise.then(
      (value: T): void => {
        callback(undefined, value);
      },
      callback
    );
  }
}

export = Future;

/**
 * @callback ApplyCallback
 * @returns T
 */
/**
 * @callback TryCallback
 * @param {any} err
 * @param {T} value
 */
/**
 * @callback SuccessCallback
 * @param {T} value
 * @returns {U}
 */
/**
 * @callback FailCallback
 * @param {any} err
 * @returns {any}
 */
/**
 * @callback RecoverCallback
 * @param {any} err
 * @returns {T}
 */
/**
 * @callback RecoverWithCallback
 * @param {any} err
 * @returns {Future&lt;T>}
 */
/**
 * @callback FilterCallback
 * @param {T} value
 * @returns {boolean}
 */
/**
 * @callback MapCallback
 * @param {T} value
 * @returns {U}
 */
/**
 * @callback FlatMapCallback
 * @param {T} value
 * @returns {Future&lt;U>}
 */
/**
 * @callback FoldCallback
 * @param {U} base
 * @param {T} value
 * @returns U
 */
</pre>
        </article>
    </section>





				</div>

				<div class="clearfix"></div>
				<footer>
					
					
						<span class="copyright">
						sfuture Copyright © 2015 ruwin126.
						</span>
									<br />
									
						<span class="jsdoc-message">
						Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.2</a>
						on Mon Aug 31 2015 22:10:03 GMT+0900 (KST) using the <a href="https://github.com/xperiments/TSDoc">TSDoc template</a>.
						</span>
				</footer>
			</div>
			<!--
			
			-->
			<br clear="both">
		</div>

	</div>

	<script src="scripts/sunlight.js"></script>
	<script src="scripts/sunlight.javascript.js"></script>
	<script src="scripts/sunlight-plugin.doclinks.js"></script>
	<script src="scripts/sunlight-plugin.linenumbers.js"></script>
	<script src="scripts/sunlight-plugin.menu.js"></script>
	<script src="scripts/jquery.min.js"></script>
	<script src="scripts/jquery.scrollTo.js"></script>
	<script src="scripts/jquery.localScroll.js"></script>
	<script src="scripts/bootstrap.min.js"></script>



	<script>  Sunlight.highlightAll({lineNumbers:false,  showMenu: true, enableDoclinks :true}); </script>

	<script>
		$( function () {

			var searchItems = [];
			var searchMap = {};
			var mapName = "";
			for( var i=0; i<searchMembers.length; i++ )
			{
				realName = searchMembers[i].realName;
				searchItems.push( realName );
				searchMap[ realName ] = searchMembers[ i ];
			}


			$('.typeahead').typeahead({
			  source: searchItems,
			  matcher: function(item) {
			  	//console.log('aaa'+item, this.query, item.indexOf( this.query.toLowerCase() )==-1?false:true)
                // evaluate item variable and return true if the item was matched.
                return item.toLowerCase().indexOf( this.query.toLowerCase() )==-1?false:true;
             },
			  updater: function (item) {
					window.location.href = searchMap[ item ].link+'.html';
			  }

			});


            // Move Tutorials to bottom
            //$('#menuContainer').append($('#navTitle_Tutorials'));
            //$('#menuContainer').append($('#navContents_Tutorials'));
			$(window).resize(function() {
			  $('#side-menu').height( $(window).height()-70 );
			  $('#sideMenuFrame').height( $(window).height()-140 );
			  if( $(window).width() <480 )
			  {
			  	$('#side-menu').hide();
				$('#docContents').removeClass('sideMenu');
			  }
			});

			$(window).trigger('resize')
			$('#btnCollapse').click(function()
			{
				$('#side-menu').toggle();
				$('#docContents').toggleClass('sideMenu');

			})
			$('#btnHome').click(function()
			{
				document.location.href="index.html"

			})		

			$('.sourceBar').click(function(){})
			var lastMenuSelection = window.localStorage.getItem('lastMenuSelection') || null;
			if( lastMenuSelection ) $('a[data-id='+lastMenuSelection+']').click();
			$('a[data-toggle=collapse]').click(function(){
				if( lastMenuSelection == $(this).attr('data-id') ) return;
				if( lastMenuSelection ) $('a[data-id='+lastMenuSelection+']').click();
				lastMenuSelection = $(this).attr('data-id');
				window.localStorage.setItem('lastMenuSelection', lastMenuSelection )
			});	


		} );
	</script>

	
	<script>
		$( function () {
			$('#main').localScroll({
				offset: { top: 56 } //offset by the height of your header (give or take a few px, see what works for you)
			});
			$(".routeTitle").on('click', function(){
			    $(this).next().slideToggle();
			});
			$( "dt h4.name" ).each( function () {
				var $this = $( this );
				//var icon = $( "<i/>" ).addClass( "icon-plus-sign" ).addClass( "pull-right" );
				var dt = $this.parents( "dt" );
				var children = dt.next( "dd" );

				//$this.append( icon ).css( {cursor : "pointer"} );
				$this.addClass( "member-collapsed" ).addClass( "member" );

				children.hide();
				$this.toggle( function () {
					//icon.addClass( "icon-minus-sign" ).removeClass( "icon-plus-sign" );
					$this.addClass( "member-open" ).removeClass( "member-collapsed" );
					children.slideDown();
				}, function () {
					//icon.addClass( "icon-plus-sign" ).removeClass( "icon-minus-sign" );
					$this.addClass( "member-collapsed" ).removeClass( "member-open" );
					children.slideUp();
				} );
			} );
			$('.sourceBar').click(function(event){event.stopPropagation();})
		} );
	</script>
	

</body>
</html>
